<!doctype html>
<html class="no-js" lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>
    
  数据结构-图 - NeverMoes 的笔记
  
  </title>
 <meta name="description" content="">
 <link href="atom.xml" rel="alternate" title="NeverMoes 的笔记" type="application/atom+xml">
    <link rel="stylesheet" href="asset/css/foundation.min.css" />
    <link rel="stylesheet" href="asset/css/docs.css" />

    <script src="asset/js/vendor/modernizr.js"></script>
    <script src="asset/js/vendor/jquery.js"></script>
    <script src="asset/highlightjs/highlight.pack.js"></script>
    <link href="asset/highlightjs/styles/github.css" media="screen, projection" rel="stylesheet" type="text/css">
    <script>hljs.initHighlightingOnLoad();</script>
    
  </head>
  <body class="antialiased hide-extras">
    
    <div class="marketing off-canvas-wrap" data-offcanvas>
      <div class="inner-wrap">


<nav class="top-bar docs-bar hide-for-small" data-topbar>

<div id="header">
    <h1><a href="index.html">NeverMoes 的笔记</a></h1>
</div>

</nav>
        <nav class="tab-bar show-for-small">
  <a href="javascript:void(0)" class="left-off-canvas-toggle menu-icon">
    <span> &nbsp; NeverMoes 的笔记</span>
  </a>
</nav>

<aside class="left-off-canvas-menu">
      <ul class="off-canvas-list">
      <li><a href="index.html">Home</a></li>
      
        <li class="divider"></li>
        <li><label>Java</label></li>

          
            <li><a title="Java - 编码" href="15613569036612.html">Java - 编码</a></li>
          
            <li><a title="Java - Log" href="15594642382768.html">Java - Log</a></li>
          
            <li><a title="Java - 异常处理" href="15594627836663.html">Java - 异常处理</a></li>
          
            <li><a title="Java - Steam" href="15584212270447.html">Java - Steam</a></li>
          
            <li><a title="Java - 反射" href="15580921637682.html">Java - 反射</a></li>
          
            <li><a title="Java - Enum" href="15580808809919.html">Java - Enum</a></li>
          
            <li><a title="Javadoc" href="15573232964198.html">Javadoc</a></li>
          
            <li><a title="编程规范" href="15573214224993.html">编程规范</a></li>
          
            <li><a title="Java8" href="15571102853200.html">Java8</a></li>
          
            <li><a title="一些特性" href="15568697463497.html">一些特性</a></li>
          
            <li><a title="Java 补充" href="15557361529750.html">Java 补充</a></li>
          
            <li><a title="Java 基础" href="15554689517828.html">Java 基础</a></li>
          
            <li><a title="Java - IO" href="15551380554375.html">Java - IO</a></li>
          
            <li><a title="Java 经典设计模式" href="15548114065751.html">Java 经典设计模式</a></li>
          
            <li><a title="常用设计模式" href="15547272355117.html">常用设计模式</a></li>
          
            <li><a title="Java - 流(Stream)" href="15535872722415.html">Java - 流(Stream)</a></li>
          

      
        <li class="divider"></li>
        <li><label>Java 集合</label></li>

          
            <li><a title="Java 集合 - List" href="15619627957699.html">Java 集合 - List</a></li>
          
            <li><a title="Java - 集合框架" href="15557398305311.html">Java - 集合框架</a></li>
          

      
        <li class="divider"></li>
        <li><label>并发</label></li>

          
            <li><a title="Java 并发 - 同步器框架 AQS" href="15628279381258.html">Java 并发 - 同步器框架 AQS</a></li>
          
            <li><a title="Java 并发 - volatile 与 Java 内存模型(JMM)" href="15628250952791.html">Java 并发 - volatile 与 Java 内存模型(JMM)</a></li>
          
            <li><a title="Java 并发 - 生产者消费者模型" href="15551273585518.html">Java 并发 - 生产者消费者模型</a></li>
          
            <li><a title="Java 并发 - atomic" href="15551259864059.html">Java 并发 - atomic</a></li>
          
            <li><a title="Java 并发 - 线程池" href="15550409896106.html">Java 并发 - 线程池</a></li>
          
            <li><a title="Java 并发 - 常见并发容器" href="15549779705652.html">Java 并发 - 常见并发容器</a></li>
          
            <li><a title="Java 并发 - final 重排" href="15549631305867.html">Java 并发 - final 重排</a></li>
          
            <li><a title="Java 并发 - synchronized" href="15549492034730.html">Java 并发 - synchronized</a></li>
          
            <li><a title="Java 并发 - 线程" href="15549491562348.html">Java 并发 - 线程</a></li>
          
            <li><a title="Java 并发 - 常用同步器" href="15549094953523.html">Java 并发 - 常用同步器</a></li>
          
            <li><a title="Java 并发 - 概览" href="15536711259128.html">Java 并发 - 概览</a></li>
          

      
        <li class="divider"></li>
        <li><label>JVM</label></li>

          
            <li><a title="Java JVM - 分析工具" href="15592858144445.html">Java JVM - 分析工具</a></li>
          
            <li><a title="Java JVM - 类加载" href="15554954352575.html">Java JVM - 类加载</a></li>
          
            <li><a title="Java JVM - GC" href="15551422971585.html">Java JVM - GC</a></li>
          
            <li><a title="Java JVM - 内存布局" href="15551417067858.html">Java JVM - 内存布局</a></li>
          

      
        <li class="divider"></li>
        <li><label>Spring</label></li>

          
            <li><a title="Mybatis" href="15627234169476.html">Mybatis</a></li>
          
            <li><a title="Spring -  自定义标签" href="15580023414897.html">Spring -  自定义标签</a></li>
          
            <li><a title="Java - Servlet" href="15555575014317.html">Java - Servlet</a></li>
          
            <li><a title="Spring - 数据访问" href="15553337118605.html">Spring - 数据访问</a></li>
          
            <li><a title="spring 异步线程池" href="15546347724247.html">spring 异步线程池</a></li>
          
            <li><a title="Spring MVC" href="15546192348918.html">Spring MVC</a></li>
          
            <li><a title="Spring 事务" href="15544558066181.html">Spring 事务</a></li>
          
            <li><a title="Spring AOP" href="15543917219955.html">Spring AOP</a></li>
          
            <li><a title="Spring IoC" href="15543630452997.html">Spring IoC</a></li>
          

      
        <li class="divider"></li>
        <li><label>源码</label></li>

          
            <li><a title="源码" href="15627233586740.html">源码</a></li>
          

      
        <li class="divider"></li>
        <li><label>Redis</label></li>

          
            <li><a title="Redis 实现分布式锁" href="15565438727155.html">Redis 实现分布式锁</a></li>
          
            <li><a title="Redis 深入 - 双写一致性" href="15560904222673.html">Redis 深入 - 双写一致性</a></li>
          
            <li><a title="Redis 深入 - 高可用性" href="15560904056716.html">Redis 深入 - 高可用性</a></li>
          
            <li><a title="Redis 深入 - 数据结构" href="15560812001633.html">Redis 深入 - 数据结构</a></li>
          
            <li><a title="Redis 深入 - 常见问题" href="15556760212710.html">Redis 深入 - 常见问题</a></li>
          
            <li><a title="Redis 基本使用" href="15542783465338.html">Redis 基本使用</a></li>
          

      
        <li class="divider"></li>
        <li><label>Mysql</label></li>

          
            <li><a title="Mysql - 键、索引、约束" href="15633466729778.html">Mysql - 键、索引、约束</a></li>
          
            <li><a title="Mysql - 性能优化" href="15633423972144.html">Mysql - 性能优化</a></li>
          
            <li><a title="索引中的树 - B,B+,B*" href="15633420860231.html">索引中的树 - B,B+,B*</a></li>
          
            <li><a title="性能优化" href="15607574336137.html">性能优化</a></li>
          
            <li><a title="Mysql - EXPLAIN" href="15607559623364.html">Mysql - EXPLAIN</a></li>
          
            <li><a title="Mysql 深入" href="15555007777074.html">Mysql 深入</a></li>
          
            <li><a title="Mysql 基本使用" href="15554985061309.html">Mysql 基本使用</a></li>
          

      
        <li class="divider"></li>
        <li><label>消息队列</label></li>

          
            <li><a title="JMS" href="15584265544434.html">JMS</a></li>
          
            <li><a title="RPC - RMI" href="15572232721703.html">RPC - RMI</a></li>
          
            <li><a title="消息队列" href="15560753193297.html">消息队列</a></li>
          

      
        <li class="divider"></li>
        <li><label>分布式</label></li>

          
            <li><a title="概览" href="15630938148608.html">概览</a></li>
          
            <li><a title="分布式锁" href="15625959085058.html">分布式锁</a></li>
          
            <li><a title="分布式事务" href="15625700887049.html">分布式事务</a></li>
          
            <li><a title="ZooKeeper - 实现原理" href="15574104902395.html">ZooKeeper - 实现原理</a></li>
          
            <li><a title="ZK 分布式锁" href="15573683537890.html">ZK 分布式锁</a></li>
          
            <li><a title="ZooKeeper - 基本使用" href="15572415140464.html">ZooKeeper - 基本使用</a></li>
          
            <li><a title="Dubbo" href="15572232166193.html">Dubbo</a></li>
          
            <li><a title="分布式 - 一致性协议" href="15564260705049.html">分布式 - 一致性协议</a></li>
          
            <li><a title="ZooKeeper - ZAB 一致性协议" href="15561221442316.html">ZooKeeper - ZAB 一致性协议</a></li>
          
            <li><a title="分布式 - 理论" href="15559475613873.html">分布式 - 理论</a></li>
          

      
        <li class="divider"></li>
        <li><label>LeetCode</label></li>

          
            <li><a title="栈" href="15641207902154.html">栈</a></li>
          
            <li><a title="链表" href="15640409436152.html">链表</a></li>
          
            <li><a title="位运算" href="15640226818030.html">位运算</a></li>
          
            <li><a title="树相关" href="15638876391543.html">树相关</a></li>
          
            <li><a title="并查集(union-find)" href="15637156793274.html">并查集(union-find)</a></li>
          
            <li><a title="图相关" href="15637123231485.html">图相关</a></li>
          
            <li><a title="动态规划 - 2" href="15637092754569.html">动态规划 - 2</a></li>
          
            <li><a title="其他" href="15632741408063.html">其他</a></li>
          
            <li><a title="动态规划 - 2" href="15621444826793.html">动态规划 - 2</a></li>
          
            <li><a title="字符串" href="15621426919335.html">字符串</a></li>
          
            <li><a title="贪心策略" href="15621379435201.html">贪心策略</a></li>
          
            <li><a title="动态规划 - 1" href="15618801162146.html">动态规划 - 1</a></li>
          
            <li><a title="回溯" href="15617108626739.html">回溯</a></li>
          
            <li><a title="组合博弈" href="15617105581442.html">组合博弈</a></li>
          
            <li><a title="temp" href="15600064978396.html">temp</a></li>
          
            <li><a title="筛选法" href="15600041568309.html">筛选法</a></li>
          
            <li><a title="Sell Stock" href="15592212071515.html">Sell Stock</a></li>
          
            <li><a title="dfs" href="15590119399452.html">dfs</a></li>
          
            <li><a title="Index" href="15578365171892.html">Index</a></li>
          
            <li><a title="排序" href="15578363359025.html">排序</a></li>
          

      
        <li class="divider"></li>
        <li><label>算法</label></li>

          
            <li><a title="海量数据" href="15635229096880.html">海量数据</a></li>
          
            <li><a title="缓存" href="15616272119801.html">缓存</a></li>
          
            <li><a title="位操作" href="15421595266112.html">位操作</a></li>
          
            <li><a title="数据结构-搜索树" href="15382213735628.html">数据结构-搜索树</a></li>
          
            <li><a title="数据结构-查找" href="15381206652033.html">数据结构-查找</a></li>
          
            <li><a title="数据结构-栈与队列" href="15377961916563.html">数据结构-栈与队列</a></li>
          
            <li><a title="数据结构-树" href="15376956161325.html">数据结构-树</a></li>
          
            <li><a title="数据结构-图" href="15366535602244.html">数据结构-图</a></li>
          
            <li><a title="数据结构-排序" href="15366378611089.html">数据结构-排序</a></li>
          
            <li><a title="数据结构-线性表" href="15365715348624.html">数据结构-线性表</a></li>
          
            <li><a title="数据结构-绪论" href="15364817197942.html">数据结构-绪论</a></li>
          
            <li><a title="算法学习路径" href="15289789971496.html">算法学习路径</a></li>
          

      
        <li class="divider"></li>
        <li><label>工具</label></li>

          
            <li><a title="MyBatis" href="15590240129274.html">MyBatis</a></li>
          
            <li><a title="Guava" href="15573643454153.html">Guava</a></li>
          
            <li><a title="Lombok" href="15571355421205.html">Lombok</a></li>
          
            <li><a title="IntelliJ-IDEA" href="15568897283887.html">IntelliJ-IDEA</a></li>
          
            <li><a title="Git" href="15568705670148.html">Git</a></li>
          
            <li><a title="Maven" href="15547227910617.html">Maven</a></li>
          

      
        <li class="divider"></li>
        <li><label>网络</label></li>

          
            <li><a title="Netty" href="15633460791334.html">Netty</a></li>
          
            <li><a title="Http 授权" href="15629155221529.html">Http 授权</a></li>
          
            <li><a title="Https" href="15627233138405.html">Https</a></li>
          
            <li><a title="Http" href="15627233041942.html">Http</a></li>
          
            <li><a title="TCP" href="15627232889065.html">TCP</a></li>
          
            <li><a title="重要知识点" href="15561544288813.html">重要知识点</a></li>
          

      
        <li class="divider"></li>
        <li><label>Linux</label></li>

          
            <li><a title="Linux - I/O 模型" href="15560816178760.html">Linux - I/O 模型</a></li>
          
            <li><a title="Linux" href="15556621779917.html">Linux</a></li>
          

      
        <li class="divider"></li>
        <li><label>测试相关</label></li>

          
            <li><a title="Mockito" href="15590126556449.html">Mockito</a></li>
          
            <li><a title="测试相关" href="15587730878715.html">测试相关</a></li>
          
            <li><a title="JUnit" href="15579238927247.html">JUnit</a></li>
          
            <li><a title="测试" href="15579095305456.html">测试</a></li>
          

      
        <li class="divider"></li>
        <li><label>Web</label></li>

          
            <li><a title="Http 缓存控制" href="15616231135862.html">Http 缓存控制</a></li>
          
            <li><a title="HTTP API 认证" href="15616218028083.html">HTTP API 认证</a></li>
          

      
        <li class="divider"></li>
        <li><label>其他</label></li>

          
            <li><a title="计算机中的时间处理" href="15414917404912.html">计算机中的时间处理</a></li>
          

      
      </ul>
    </aside>

<a class="exit-off-canvas" href="#"></a>

        <section id="main-content" role="main" class="scroll-container">

          <div class="row">
            <div class="large-3 medium-3 columns">
              <div class="hide-for-small">
                <div class="sidebar">
                <nav>
                  <ul id="side-nav" class="side-nav">

                    
                      <li class="side-title"><span>Java</span></li>
                        
                          <li><a title="Java - 编码" href="15613569036612.html">Java - 编码</a></li>
                        
                          <li><a title="Java - Log" href="15594642382768.html">Java - Log</a></li>
                        
                          <li><a title="Java - 异常处理" href="15594627836663.html">Java - 异常处理</a></li>
                        
                          <li><a title="Java - Steam" href="15584212270447.html">Java - Steam</a></li>
                        
                          <li><a title="Java - 反射" href="15580921637682.html">Java - 反射</a></li>
                        
                          <li><a title="Java - Enum" href="15580808809919.html">Java - Enum</a></li>
                        
                          <li><a title="Javadoc" href="15573232964198.html">Javadoc</a></li>
                        
                          <li><a title="编程规范" href="15573214224993.html">编程规范</a></li>
                        
                          <li><a title="Java8" href="15571102853200.html">Java8</a></li>
                        
                          <li><a title="一些特性" href="15568697463497.html">一些特性</a></li>
                        
                          <li><a title="Java 补充" href="15557361529750.html">Java 补充</a></li>
                        
                          <li><a title="Java 基础" href="15554689517828.html">Java 基础</a></li>
                        
                          <li><a title="Java - IO" href="15551380554375.html">Java - IO</a></li>
                        
                          <li><a title="Java 经典设计模式" href="15548114065751.html">Java 经典设计模式</a></li>
                        
                          <li><a title="常用设计模式" href="15547272355117.html">常用设计模式</a></li>
                        
                          <li><a title="Java - 流(Stream)" href="15535872722415.html">Java - 流(Stream)</a></li>
                        

                    
                      <li class="side-title"><span>Java 集合</span></li>
                        
                          <li><a title="Java 集合 - List" href="15619627957699.html">Java 集合 - List</a></li>
                        
                          <li><a title="Java - 集合框架" href="15557398305311.html">Java - 集合框架</a></li>
                        

                    
                      <li class="side-title"><span>并发</span></li>
                        
                          <li><a title="Java 并发 - 同步器框架 AQS" href="15628279381258.html">Java 并发 - 同步器框架 AQS</a></li>
                        
                          <li><a title="Java 并发 - volatile 与 Java 内存模型(JMM)" href="15628250952791.html">Java 并发 - volatile 与 Java 内存模型(JMM)</a></li>
                        
                          <li><a title="Java 并发 - 生产者消费者模型" href="15551273585518.html">Java 并发 - 生产者消费者模型</a></li>
                        
                          <li><a title="Java 并发 - atomic" href="15551259864059.html">Java 并发 - atomic</a></li>
                        
                          <li><a title="Java 并发 - 线程池" href="15550409896106.html">Java 并发 - 线程池</a></li>
                        
                          <li><a title="Java 并发 - 常见并发容器" href="15549779705652.html">Java 并发 - 常见并发容器</a></li>
                        
                          <li><a title="Java 并发 - final 重排" href="15549631305867.html">Java 并发 - final 重排</a></li>
                        
                          <li><a title="Java 并发 - synchronized" href="15549492034730.html">Java 并发 - synchronized</a></li>
                        
                          <li><a title="Java 并发 - 线程" href="15549491562348.html">Java 并发 - 线程</a></li>
                        
                          <li><a title="Java 并发 - 常用同步器" href="15549094953523.html">Java 并发 - 常用同步器</a></li>
                        
                          <li><a title="Java 并发 - 概览" href="15536711259128.html">Java 并发 - 概览</a></li>
                        

                    
                      <li class="side-title"><span>JVM</span></li>
                        
                          <li><a title="Java JVM - 分析工具" href="15592858144445.html">Java JVM - 分析工具</a></li>
                        
                          <li><a title="Java JVM - 类加载" href="15554954352575.html">Java JVM - 类加载</a></li>
                        
                          <li><a title="Java JVM - GC" href="15551422971585.html">Java JVM - GC</a></li>
                        
                          <li><a title="Java JVM - 内存布局" href="15551417067858.html">Java JVM - 内存布局</a></li>
                        

                    
                      <li class="side-title"><span>Spring</span></li>
                        
                          <li><a title="Mybatis" href="15627234169476.html">Mybatis</a></li>
                        
                          <li><a title="Spring -  自定义标签" href="15580023414897.html">Spring -  自定义标签</a></li>
                        
                          <li><a title="Java - Servlet" href="15555575014317.html">Java - Servlet</a></li>
                        
                          <li><a title="Spring - 数据访问" href="15553337118605.html">Spring - 数据访问</a></li>
                        
                          <li><a title="spring 异步线程池" href="15546347724247.html">spring 异步线程池</a></li>
                        
                          <li><a title="Spring MVC" href="15546192348918.html">Spring MVC</a></li>
                        
                          <li><a title="Spring 事务" href="15544558066181.html">Spring 事务</a></li>
                        
                          <li><a title="Spring AOP" href="15543917219955.html">Spring AOP</a></li>
                        
                          <li><a title="Spring IoC" href="15543630452997.html">Spring IoC</a></li>
                        

                    
                      <li class="side-title"><span>源码</span></li>
                        
                          <li><a title="源码" href="15627233586740.html">源码</a></li>
                        

                    
                      <li class="side-title"><span>Redis</span></li>
                        
                          <li><a title="Redis 实现分布式锁" href="15565438727155.html">Redis 实现分布式锁</a></li>
                        
                          <li><a title="Redis 深入 - 双写一致性" href="15560904222673.html">Redis 深入 - 双写一致性</a></li>
                        
                          <li><a title="Redis 深入 - 高可用性" href="15560904056716.html">Redis 深入 - 高可用性</a></li>
                        
                          <li><a title="Redis 深入 - 数据结构" href="15560812001633.html">Redis 深入 - 数据结构</a></li>
                        
                          <li><a title="Redis 深入 - 常见问题" href="15556760212710.html">Redis 深入 - 常见问题</a></li>
                        
                          <li><a title="Redis 基本使用" href="15542783465338.html">Redis 基本使用</a></li>
                        

                    
                      <li class="side-title"><span>Mysql</span></li>
                        
                          <li><a title="Mysql - 键、索引、约束" href="15633466729778.html">Mysql - 键、索引、约束</a></li>
                        
                          <li><a title="Mysql - 性能优化" href="15633423972144.html">Mysql - 性能优化</a></li>
                        
                          <li><a title="索引中的树 - B,B+,B*" href="15633420860231.html">索引中的树 - B,B+,B*</a></li>
                        
                          <li><a title="性能优化" href="15607574336137.html">性能优化</a></li>
                        
                          <li><a title="Mysql - EXPLAIN" href="15607559623364.html">Mysql - EXPLAIN</a></li>
                        
                          <li><a title="Mysql 深入" href="15555007777074.html">Mysql 深入</a></li>
                        
                          <li><a title="Mysql 基本使用" href="15554985061309.html">Mysql 基本使用</a></li>
                        

                    
                      <li class="side-title"><span>消息队列</span></li>
                        
                          <li><a title="JMS" href="15584265544434.html">JMS</a></li>
                        
                          <li><a title="RPC - RMI" href="15572232721703.html">RPC - RMI</a></li>
                        
                          <li><a title="消息队列" href="15560753193297.html">消息队列</a></li>
                        

                    
                      <li class="side-title"><span>分布式</span></li>
                        
                          <li><a title="概览" href="15630938148608.html">概览</a></li>
                        
                          <li><a title="分布式锁" href="15625959085058.html">分布式锁</a></li>
                        
                          <li><a title="分布式事务" href="15625700887049.html">分布式事务</a></li>
                        
                          <li><a title="ZooKeeper - 实现原理" href="15574104902395.html">ZooKeeper - 实现原理</a></li>
                        
                          <li><a title="ZK 分布式锁" href="15573683537890.html">ZK 分布式锁</a></li>
                        
                          <li><a title="ZooKeeper - 基本使用" href="15572415140464.html">ZooKeeper - 基本使用</a></li>
                        
                          <li><a title="Dubbo" href="15572232166193.html">Dubbo</a></li>
                        
                          <li><a title="分布式 - 一致性协议" href="15564260705049.html">分布式 - 一致性协议</a></li>
                        
                          <li><a title="ZooKeeper - ZAB 一致性协议" href="15561221442316.html">ZooKeeper - ZAB 一致性协议</a></li>
                        
                          <li><a title="分布式 - 理论" href="15559475613873.html">分布式 - 理论</a></li>
                        

                    
                      <li class="side-title"><span>LeetCode</span></li>
                        
                          <li><a title="栈" href="15641207902154.html">栈</a></li>
                        
                          <li><a title="链表" href="15640409436152.html">链表</a></li>
                        
                          <li><a title="位运算" href="15640226818030.html">位运算</a></li>
                        
                          <li><a title="树相关" href="15638876391543.html">树相关</a></li>
                        
                          <li><a title="并查集(union-find)" href="15637156793274.html">并查集(union-find)</a></li>
                        
                          <li><a title="图相关" href="15637123231485.html">图相关</a></li>
                        
                          <li><a title="动态规划 - 2" href="15637092754569.html">动态规划 - 2</a></li>
                        
                          <li><a title="其他" href="15632741408063.html">其他</a></li>
                        
                          <li><a title="动态规划 - 2" href="15621444826793.html">动态规划 - 2</a></li>
                        
                          <li><a title="字符串" href="15621426919335.html">字符串</a></li>
                        
                          <li><a title="贪心策略" href="15621379435201.html">贪心策略</a></li>
                        
                          <li><a title="动态规划 - 1" href="15618801162146.html">动态规划 - 1</a></li>
                        
                          <li><a title="回溯" href="15617108626739.html">回溯</a></li>
                        
                          <li><a title="组合博弈" href="15617105581442.html">组合博弈</a></li>
                        
                          <li><a title="temp" href="15600064978396.html">temp</a></li>
                        
                          <li><a title="筛选法" href="15600041568309.html">筛选法</a></li>
                        
                          <li><a title="Sell Stock" href="15592212071515.html">Sell Stock</a></li>
                        
                          <li><a title="dfs" href="15590119399452.html">dfs</a></li>
                        
                          <li><a title="Index" href="15578365171892.html">Index</a></li>
                        
                          <li><a title="排序" href="15578363359025.html">排序</a></li>
                        

                    
                      <li class="side-title"><span>算法</span></li>
                        
                          <li><a title="海量数据" href="15635229096880.html">海量数据</a></li>
                        
                          <li><a title="缓存" href="15616272119801.html">缓存</a></li>
                        
                          <li><a title="位操作" href="15421595266112.html">位操作</a></li>
                        
                          <li><a title="数据结构-搜索树" href="15382213735628.html">数据结构-搜索树</a></li>
                        
                          <li><a title="数据结构-查找" href="15381206652033.html">数据结构-查找</a></li>
                        
                          <li><a title="数据结构-栈与队列" href="15377961916563.html">数据结构-栈与队列</a></li>
                        
                          <li><a title="数据结构-树" href="15376956161325.html">数据结构-树</a></li>
                        
                          <li><a title="数据结构-图" href="15366535602244.html">数据结构-图</a></li>
                        
                          <li><a title="数据结构-排序" href="15366378611089.html">数据结构-排序</a></li>
                        
                          <li><a title="数据结构-线性表" href="15365715348624.html">数据结构-线性表</a></li>
                        
                          <li><a title="数据结构-绪论" href="15364817197942.html">数据结构-绪论</a></li>
                        
                          <li><a title="算法学习路径" href="15289789971496.html">算法学习路径</a></li>
                        

                    
                      <li class="side-title"><span>工具</span></li>
                        
                          <li><a title="MyBatis" href="15590240129274.html">MyBatis</a></li>
                        
                          <li><a title="Guava" href="15573643454153.html">Guava</a></li>
                        
                          <li><a title="Lombok" href="15571355421205.html">Lombok</a></li>
                        
                          <li><a title="IntelliJ-IDEA" href="15568897283887.html">IntelliJ-IDEA</a></li>
                        
                          <li><a title="Git" href="15568705670148.html">Git</a></li>
                        
                          <li><a title="Maven" href="15547227910617.html">Maven</a></li>
                        

                    
                      <li class="side-title"><span>网络</span></li>
                        
                          <li><a title="Netty" href="15633460791334.html">Netty</a></li>
                        
                          <li><a title="Http 授权" href="15629155221529.html">Http 授权</a></li>
                        
                          <li><a title="Https" href="15627233138405.html">Https</a></li>
                        
                          <li><a title="Http" href="15627233041942.html">Http</a></li>
                        
                          <li><a title="TCP" href="15627232889065.html">TCP</a></li>
                        
                          <li><a title="重要知识点" href="15561544288813.html">重要知识点</a></li>
                        

                    
                      <li class="side-title"><span>Linux</span></li>
                        
                          <li><a title="Linux - I/O 模型" href="15560816178760.html">Linux - I/O 模型</a></li>
                        
                          <li><a title="Linux" href="15556621779917.html">Linux</a></li>
                        

                    
                      <li class="side-title"><span>测试相关</span></li>
                        
                          <li><a title="Mockito" href="15590126556449.html">Mockito</a></li>
                        
                          <li><a title="测试相关" href="15587730878715.html">测试相关</a></li>
                        
                          <li><a title="JUnit" href="15579238927247.html">JUnit</a></li>
                        
                          <li><a title="测试" href="15579095305456.html">测试</a></li>
                        

                    
                      <li class="side-title"><span>Web</span></li>
                        
                          <li><a title="Http 缓存控制" href="15616231135862.html">Http 缓存控制</a></li>
                        
                          <li><a title="HTTP API 认证" href="15616218028083.html">HTTP API 认证</a></li>
                        

                    
                      <li class="side-title"><span>其他</span></li>
                        
                          <li><a title="计算机中的时间处理" href="15414917404912.html">计算机中的时间处理</a></li>
                        

                    
                  </ul>
                </nav>
                </div>
              </div>
            </div>
            <div class="large-9 medium-9 columns">

 <div class="markdown-body">
<h1>数据结构-图</h1>

<ul>
<li>
<a href="#toc_0">概念</a>
<ul>
<li>
<a href="#toc_1">定义</a>
<ul>
<li>
<a href="#toc_2">分类</a>
</li>
<li>
<a href="#toc_3">属性</a>
</li>
<li>
<a href="#toc_4">无向图属性</a>
</li>
<li>
<a href="#toc_5">有向图属性</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_6">存储</a>
<ul>
<li>
<a href="#toc_7">邻接矩阵</a>
<ul>
<li>
<a href="#toc_8">概念</a>
</li>
<li>
<a href="#toc_9">定义</a>
</li>
<li>
<a href="#toc_10">性质</a>
</li>
</ul>
</li>
<li>
<a href="#toc_11">邻接表</a>
<ul>
<li>
<a href="#toc_12">概念</a>
</li>
<li>
<a href="#toc_13">定义</a>
</li>
<li>
<a href="#toc_14">性质</a>
</li>
</ul>
</li>
<li>
<a href="#toc_15">十字链表</a>
<ul>
<li>
<a href="#toc_16">概念</a>
</li>
<li>
<a href="#toc_17">定义</a>
</li>
</ul>
</li>
<li>
<a href="#toc_18">邻接多重表</a>
<ul>
<li>
<a href="#toc_19">概念</a>
</li>
<li>
<a href="#toc_20">定义</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_21">基本操作</a>
</li>
<li>
<a href="#toc_22">遍历</a>
<ul>
<li>
<a href="#toc_23">广度优先</a>
</li>
<li>
<a href="#toc_24">深度优先</a>
</li>
</ul>
</li>
<li>
<a href="#toc_25">最小生成树</a>
<ul>
<li>
<a href="#toc_26">Prim</a>
</li>
<li>
<a href="#toc_27">kruskal</a>
</li>
</ul>
</li>
<li>
<a href="#toc_28">最短路径</a>
<ul>
<li>
<a href="#toc_29">Dijkstra</a>
</li>
<li>
<a href="#toc_30">Floyd</a>
</li>
</ul>
</li>
<li>
<a href="#toc_31">拓扑排序</a>
<ul>
<li>
<a href="#toc_32">概念</a>
</li>
<li>
<a href="#toc_33">算法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_34">关键路径</a>
<ul>
<li>
<a href="#toc_35">概念</a>
</li>
<li>
<a href="#toc_36">算法</a>
</li>
</ul>
</li>
<li>
<a href="#toc_37">习题</a>
</li>
</ul>


<h2 id="toc_0">概念</h2>

<h3 id="toc_1">定义</h3>

<ul>
<li>图G由点集V和边集E组成，记为G=(V,E)。</li>
<li><strong>点集不能为空</strong>，边集可以为空。</li>
<li>|V|，\(V=v_1,\cdots,v_n\)表示图点的个数，也称为图的<strong>阶</strong>。</li>
<li>|E|，\(E=\{(u,v),u\in V,v\in V\}\)表示图边的个数。</li>
</ul>

<p><strong>有向图</strong></p>

<ul>
<li><strong>弧</strong>是点的有序对，记做<strong><v,u></strong>。</li>
<li><v,u>中，v 为弧尾，w 为弧头，称点 v 到点 u 的弧，或 v 邻接到 u。</li>
</ul>

<p><strong>无向图</strong></p>

<ul>
<li><strong>边</strong>是点的无序对，记做<strong>(v,u)</strong>或<strong>(u,v)</strong>。</li>
<li>(v,u)中，称 v 和 u 互为邻接。</li>
</ul>

<h4 id="toc_2">分类</h4>

<p><strong>简单图</strong>，图G满足：</p>

<ul>
<li>不存在重复边。</li>
<li>不存在点到自身的边。</li>
</ul>

<p><strong>多重图</strong>，非简单图即为多重图。</p>

<h4 id="toc_3">属性</h4>

<p><strong>路径</strong>，点 u 到 点 v 的路是，u,a,b,c,d,...,v 的一个点序列。<br/>
<strong>路径长度</strong>，路径上<strong>边的个数</strong>。<br/>
<strong>回路(环)</strong>，路径中，第一个点和最后一个点相同。<br/>
<strong>简单路径</strong>，路径中，点序列不重复。<br/>
<strong>简单回路</strong>，回路中，点序列不重复。<br/>
<strong>距离</strong>，点 u 到 点 v 的最短路径。若不存在则路径为无穷大(∞)。</p>

<p><strong>子图</strong>，有两个图 G=(V,E) 和 G&#39;=(V&#39;,E&#39;)，\(V&#39;\in V,E&#39;\in E\) 则 G&#39; 是 G 的子图。<br/>
<strong>生成子图</strong>，子图满足 V(G&#39;)=V(G)。</p>

<p><strong>生成树</strong>，连通图中包含所有点的一个<strong>极小连通子图</strong>。</p>

<ul>
<li>若图中点为 n 则其生成树有 n-1 条边。</li>
</ul>

<p><strong>生成森林</strong>，非连通图中所有连通分量的生成树。</p>

<p><strong>带权图(网)</strong>，边上有数值的图。</p>

<h4 id="toc_4">无向图属性</h4>

<p><strong>完全图</strong>或简单完全图，无向图中，任意两个点都存在边。</p>

<ul>
<li>无向完全图中，n 个点有 n(n-1)/2 条边。</li>
</ul>

<p><strong>连通</strong>，无向图中，点 v 到 点 u 之间有路径存在，则 v,w 是连通的。<br/>
<strong>连通图</strong>，图中任意两点都连通。<br/>
<strong>连通分量</strong>，<strong>非连通图</strong>中的<strong>极大连通子图</strong>为连通分量。</p>

<ul>
<li>若一个图有 n 个点，但是只有 n-1 条边，那么必为非连通图。</li>
</ul>

<p><strong>点的度</strong>，与该点相连边的个数。记为TD(V)。</p>

<ul>
<li>无向图全部点的度之和等于边数量的两倍，因为每条边与两个点相连。</li>
</ul>

<h4 id="toc_5">有向图属性</h4>

<p><strong>有向完全图</strong>，在有向图中，任意两个点之间都存在方向相反的弧。</p>

<ul>
<li>有向完全图中，n 个点 n(n-1) 条边。</li>
</ul>

<p><strong>强连通</strong>、<strong>强连通图</strong>、<strong>强连通分量</strong>，有向图中与无向图相对的概念。<br/>
<strong>出度，入度</strong>，出度为是以点为起点的弧的数量，记为 ID(v)。入度是以点为终点的弧的数量记为 OD(v)。TD(v)=ID(v)+OD(v)。</p>

<ul>
<li>有向图全部点的出度之和与入度之和等于弧的数量。</li>
</ul>

<h2 id="toc_6">存储</h2>

<h3 id="toc_7">邻接矩阵</h3>

<h4 id="toc_8">概念</h4>

<p>邻接矩阵即使用一个矩阵来记录点与点之间的连接信息。</p>

<p>对于结点数为 n 的图 G=(V,E)的邻接矩阵A 是 nxn 的矩阵。</p>

<ul>
<li>A[i][j]=1，若(vi,vj)或<vi,vj>或(vi,vj)是E(G)中的边。</li>
<li>A[i][j]=1，若(vi,vj)或<vi,vj>或(vi,vj)不是E(G)中的边。</li>
</ul>

<p>对带权图而言，若顶点vi，vj相连则邻接矩阵中存着该边对应的权值，若不相连则用无穷大表示。</p>

<ul>
<li>A[i][j]=\(w_{ij}\)，若(vi,vj)或<vi,vj>或(vi,vj)是E(G)中的边。</li>
<li>A[i][j]=0或∞，若(vi,vj)或<vi,vj>或(vi,vj)不是E(G)中的边。
<img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181001003620414-1791329552.png" alt=""/></li>
</ul>

<h4 id="toc_9">定义</h4>

<pre class="line-numbers"><code class="language-c"># define MAXSIZE 
typedef struct {
    int vexs [MAXSIZE];
    int edges[MAXSIZE][MAXSIZE];
    int vexnum, arcnum; // 点和边的数量
}MGraph;
</code></pre>

<h4 id="toc_10">性质</h4>

<ol>
<li>无向图的邻接矩阵为对称矩阵，可以只用上或下三角。</li>
<li>对于无向图，邻接矩阵的第 i 行（列）非零元素的个数正好是第 i 个顶点的度 。</li>
<li>对于有向图，邻接矩阵的第 i 行（列）非零元素的个数正好是第 i 个顶点的出度（入度）。</li>
<li>邻接矩阵容易确定点之间是否相连，但是确定边的个数需要遍历。</li>
<li>稠密图适合使用邻接矩阵。</li>
</ol>

<h3 id="toc_11">邻接表</h3>

<h4 id="toc_12">概念</h4>

<p>对每个顶点建立一个单链表，然后所有顶点的单链表使用顺序存储。<br/>
顶点表由顶点域(data)和指向第一条邻边的指针(firstarc)构成。<br/>
边表，由邻接点域(adjvex)和指向下一条邻接边的指针域(nextarc)构成。<br/>
<img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181002100623925-2014204428.png" alt=""/></p>

<h4 id="toc_13">定义</h4>

<pre class="line-numbers"><code class="language-c">typedef struct ArcNode{  // 边结点
    int adjvex; // 边指向的点
    struct ArcNode *next; //指向的下一条边
}ArcNode;

typedef struct VNnode{ //顶点节点
    int data;
    ArcNode *first;
}VNode, AdjList[MAX]

typedef struct { //邻接表
    AdjList vertices;
    int vexnum, arcnum;
} ALGraph;
</code></pre>

<h4 id="toc_14">性质</h4>

<ol>
<li>若G为无向图，则所需的存储空间为O(|V|+2|E|)，若G为有向图，则所需的存储空间为O(|V|+|E|)。前者倍数是后者两倍是因为每条边在邻接表中出现了两次。</li>
<li>邻接表法比较适合于稀疏图。</li>
<li>点找边很容易，点找边不容易。</li>
<li>邻接表的表示不唯一</li>
</ol>

<h3 id="toc_15">十字链表</h3>

<h4 id="toc_16">概念</h4>

<p><strong>有向图</strong>的一种表示方式。<br/>
十字链表中每个弧和顶点都对应有一个结点。</p>

<ul>
<li>弧结点：tailvex, headvex, hlink, tlink, info
<ul>
<li>headvex, tailvex 分别指示头域和尾域。</li>
<li>hlink, tlink 链域指向弧头和弧尾相同的下一条弧。</li>
<li>info 指向该弧相关的信息。</li>
</ul></li>
<li>点结点：data, firstin, firstout
<ul>
<li>以该点为弧头或弧尾的第一个结点。</li>
</ul></li>
</ul>

<p><img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181002104350256-1777173835.png" alt=""/></p>

<h4 id="toc_17">定义</h4>

<pre class="line-numbers"><code class="language-c">typedef struct ArcNode{
    int tailvex, headvex;
    struct ArcNode *hlink, *tlink;
    //InfoType info;
} ArcNode;
typedef struct VNode{
    int data;
    ArcNode *firstin, *firstout;
}VNode;
typeder struct{
    VNode xlist[MAX];
    int vexnum, arcnum;
} GLGrapha;
</code></pre>

<h3 id="toc_18">邻接多重表</h3>

<h4 id="toc_19">概念</h4>

<p>邻接多重表是<strong>无向图</strong>的一种链式存储方式。</p>

<p>边结点：</p>

<ul>
<li>mark 标志域，用于标记该边是否被搜索过。</li>
<li>ivex, jvex 该边的两个顶点所在位置。</li>
<li>ilink 指向下一条依附点 ivex 的边。</li>
<li>jlink 指向下一条依附点 jvex 的边。</li>
<li>info 边相关信息的指针域。</li>
</ul>

<p>点结点：</p>

<ul>
<li>data 数据域</li>
<li>firstedge 指向第一条依附于改点的边。</li>
</ul>

<p>邻接多重表中，依附于同一点的边串联在同一链表中，由于每条边都依附于两个点，所以每个点会在边中出现两次。</p>

<p><img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181002105444015-2004917459.png" alt=""/></p>

<h4 id="toc_20">定义</h4>

<pre class="line-numbers"><code class="language-c">typedef struct ArcNode{
    bool mark;
    int ivex, jvex;
    struct ArcNode *ilink, *jlink;
    // InfoType info;
}ArcNode;
typedef struct VNode{
    int data;
    ArcNode *firstedge;
}VNode;
typedef struct {
    VNode adjmulist[MAX];
    int vexnum, arcnum;
} AMLGraph;
</code></pre>

<h2 id="toc_21">基本操作</h2>

<ul>
<li><code>Adjacent(G,x,y)</code>，判断图是否存在边(x,y)或<x,y>。</li>
<li><code>Neighbors</code>，列出图中与 x 邻接的边。</li>
<li><code>InsertVertex(G,x)</code>，在图中插入顶点 x。</li>
<li><code>DeleteVertex(G,x)</code>，在图中删除顶点 x。</li>
<li><code>AddEdge(G,x,y)</code>，如果(x,y)或<x,y>不存在，则添加。</li>
<li><code>RemoveEdge(G,x,y)</code>，如果(x,y)或<x,y>存在，则删除。</li>
<li><code>FirstNeighbor(G,x)</code>，求图中顶点 x 的第一个邻接点。存在返回顶点号，不存在返回-1。</li>
<li><code>NextNeighbor(G,x,y)</code>，返回除x的的下一个邻接点，不存在返回-1；</li>
<li><code>GetEdgeValue(G,x,y)</code>，获得(x,y)或<x,y>的权值。</li>
<li><code>SetEdgeValue(G,x,y)</code>，设置(x,y)或<x,y>的权值。</li>
</ul>

<h2 id="toc_22">遍历</h2>

<h3 id="toc_23">广度优先</h3>

<p>广度优先搜索(BFS)有点类似于二叉树的层序遍历算法。从某个顶点 v 开始遍历与 v 邻近的 w1,w2,3...，然后遍历与 w1,w2,3...wi 邻近的点。</p>

<p>由于 BFS 是一种分层的搜索算法，所以必须要借助一个辅助的空间。</p>

<pre class="line-numbers"><code class="language-c">//初始化操作
bool visited[MAX];
for(int i=0;i&lt;G.vexnum;i++) visited[i]=FALSE;

void BFSTraverse(Graph G){
    InitQueue(Q);
    for(int i=0;i&lt;G.vexnum;i++){
        if(!visited[i])
            BFS(G, i);
    }
}

void BFS(Graph G, int v){
    visit(v);
    visited[v]=TRUE;
    Enqueue(Q,v);
    while(!isEmpty(Q)){
        Dequeue(Q,v);
        for(w=FirstNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w)){
            if(!visited[w]){
                visit[w];
                visited[w]=TRUE;
                EnQueue(Q,w);
            }
        }
    }
}
</code></pre>

<p>时间复杂度分析：<br/>
邻接表：O(|V|+|E|)<br/>
邻接矩阵:O(|V|<sup>2)</sup></p>

<h3 id="toc_24">深度优先</h3>

<pre class="line-numbers"><code class="language-text">//初始化操作
bool visited[MAX];
for(int v=0;v&lt;G.vexnum;v++) visited[v]=FALSE;

void DFSTraverse(Graph G){
    for(int v=0;v&lt;G.vexnum;v++){
        if(!visited[v])
            DFS(G,v);
    }
}

void DFS(Graph G,int v){
    visit(v);
    visited[v]=TRUE;
    for(w=FistNeighbor(G,v);w&gt;=0;w=NextNeighbor(G,v,w))
        if(!visited[w]) 
            DFS(G,w)
}
</code></pre>

<h2 id="toc_25">最小生成树</h2>

<p>一个连通图的生成树是图的极小连通子图，即包含图中所有顶点，且只包含尽可能少的边的树。<br/>
对于一个<strong>带权的连通图</strong>，生成树不同，对应的权值也不同，<strong>权值最小的那棵生成树</strong>就是最小生成树。</p>

<p>对于最小生成树，有如下性质：</p>

<ol>
<li>最小生成树不唯一，但是对应的权值唯一。</li>
<li>边数为顶点数减一。</li>
</ol>

<p>构造最小生成树有多种算法，但是一般会用到以下性质：<br/>
若 G 是一个带权连通无向图，U 是 点集 V 的一个非空子集。若(u,v)其中 u∈U，v∈V-U，是一条具有最小权值的边，则必定存在一棵包含边(u,v)的最小生成树。</p>

<p>通用算法如下：</p>

<pre class="line-numbers"><code class="language-c">MST(G){
    T=NULL;
    while T未形成生成树;
        do 找到一条最小代价边(u,v)且加入 T 后不会产生回路;
            T=T∪(u,v)
}
</code></pre>

<h3 id="toc_26">Prim</h3>

<p>Prim算法的执行非常类似于寻找图最短路径的Dijkstra算法。<br/>
从某个顶点出发遍历选取周围最短的边。</p>

<pre class="line-numbers"><code class="language-c">//伪代码描述
void Prim(G,T){
    T=∅;
    U={w}; //w为任意顶点
    while((V-U)!=∅){
        找到(u,v),u∈U,v∈(V-U),且权值最小;
        T=T∪{(u,t)};
        U=U∪{v}
    }
}
</code></pre>

<p>以邻接矩阵为例：</p>

<pre class="line-numbers"><code class="language-c">void Prim(MGraph G)
{
    int sum = 0;
    int cost[MAXSIZE];
    int vexset[MAXSIZE];
    for(int i=0;i&lt;G.vexnum;i++) cost[i]=G.edges[0][i];
    for(int i=0;i&lt;G.vexnum;i++) vexset[i] = FALSE;
    vexset[0]=TRUE;

    for(int i=1;i&lt;G.vexnum;i++)
    {
        int mincost=INF;
        int minvex;
        int curvex;
        for(int j=0;j&lt;G.vexnum;j++)
        {
            if(vexset[j]==FALSE&amp;&amp;cost[j]&lt;mincost)
            {
                mincost=cost[j];
                minvex=j;
            }
            vexset[minvex]=TRUE;
            curvex = minvex;
        }
        sum+=mincost;
        for(int j=0;j&lt;G.vexnum;j++)
            if(vexset[j]==FALSE&amp;&amp;G.edges[curvex][j]&lt;cost[j])
                cost[j]=G.edges[curvex][j]
    }
}
</code></pre>

<p>Prim算法的复杂度为O(|V|<sup>2)不依赖于|E|，所以适合于边稠密的图。</sup></p>

<p>构造过程：<br/>
<img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181009152355508-535468775.png" alt=""/></p>

<h3 id="toc_27">kruskal</h3>

<p>kruskal所做的事情跟prim是反过来的，kruskal算法对边进行排序，依次选出最短的边连到顶点上。</p>

<pre class="line-numbers"><code class="language-c">//伪代码描述
void Kruskal(V,T){
    T=V;
    numS=n; //连通分量数
    while(nums&gt;1){
        从E选出权值最小的边(v,u);
        if(v和u属于T中不同的连通分量){
            T=∪{(v,u)};
            nums--;
        }
    }
}
</code></pre>

<p>同样以邻接矩阵为例。</p>

<pre class="line-numbers"><code class="language-c">typedef struct
{
    int v1,v2;
    int w;
} Road;
Road road[MAXSIZE];
int v[MAXSIZE];
int getRoot(int x)
{
    while(x!=v[x]) x=v[x];
    return x;
}
void Kruskal(MGraph G, Road road[])
{
    int sum=0;
    for(int i=0;i&lt;G.vexnum;i++) v[i]=i;
    sort(road,G.arcnum);
    for(int i=0;i&lt;G.arcnum;i++)
    {
        int v1=getRoot(road[i].v1);
        int v2=getRoot(road[i].v2);
        if(v1!=v2)
        {
            v[v1]=v2;
            sum+=road[i].w;
        }
    }
}

</code></pre>

<p>kruskal算法的复杂度为O(|E|log|E|)适合边少点多的图。</p>

<p>构造过程：<br/>
<img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181009152448537-1374278496.png" alt=""/></p>

<h2 id="toc_28">最短路径</h2>

<p>最短路径算法一般会利用最短路径的一条性质，即：两点间的最短路径也包含了路径上其他顶点间的最短路径。</p>

<h3 id="toc_29">Dijkstra</h3>

<p>Dijkstra 算法一般用于求单源最短路径问题。即一<strong>个顶点到其他顶点间的最短路径</strong>。</p>

<p>这里我们需要用到三个辅助数组：</p>

<ul>
<li><code>dist[vi]</code>，从 v0 到每个顶点 vi 的最短路径长度。</li>
<li><code>path[vi]</code>，保存从 v0 到 vi 最短路径上的前一个顶点。</li>
<li><code>set[]</code>，标记点是否被并入最短路径。</li>
</ul>

<p>执行过程：</p>

<ul>
<li>初始化：
<ul>
<li>选定源点 v0。</li>
<li>dist[vi]：若 v0 到 vi 之间若存在边，则为边上的权值，否则为∞。</li>
<li>path[vi]：若 v0 到 vi 之间存在边，则 path[vi]=v0，否则为-1。</li>
<li>set[v0]=TRUE，其余为 FALSE。</li>
</ul></li>
<li>执行：
<ol>
<li>从当前的 dist[]数组中选出最小值 dist[vu]。</li>
<li>将 set[vu] 置为TRUE。</li>
<li>检测所有 set[vi]==FALSE 的点。</li>
<li>比较 dist[vi] 和 dist[vu]+w 的大小，w 为 <vu,vi>的权值。</li>
<li>如果 dist[vu]+w&lt;dist[vi]</li>
<li>更新 path[] 并将 vu 加入路径中</li>
<li>直到遍历完所有的顶点(n-1次)</li>
</ol></li>
</ul>

<p>结合图来理解就是：</p>

<p><img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181025102953586-1615580793.png" alt=""/></p>

<p><img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181025103032940-108172764.png" alt=""/></p>

<pre class="line-numbers"><code class="language-c">void Dijkstra(MGraph G, int v)
{
    int set[MAXSIZE];
    int dist[MAXSIZE];
    int path[MAXSIZE];
    int min;
    int curvex;
    for(int i=0;i&lt;G.vexnum;i++)
    {
        dist[i]=G.edges[v][i];
        set[i]=FALSE;
        if(G.edges[v][i]&lt;INF) path[i]=v;
        else path[i]=-1;
    }
    set[v]=TRUE;path[v]=-1;
    
    for(int i=0;i&lt;G.vexnum-1;i++)
    {
        min=INF;
        for(int j=0;j&lt;G.vexnum;j++)
        {
            if(set[j]==FALSE;&amp;&amp;dist[j]&lt;min)
            {
                curvex=j;
                min=dist[j];
            }
            set[curvex]=TRUE;
        }
        for(int j=0;j&lt;G.vexnum;j++)
        {
            if(set[j]==FALSE&amp;&amp;(dist[curvex]+G.edges[curvex][j])&lt;dist[j])
            {
                dist[j]=dist[u]+G.edges[curvex][j];
                path[j]=curvex;
            }
        }
    }
}
</code></pre>

<p><strong>复杂度分析</strong>：从代码可以很容易看出来这里有两层的for循环，时间复杂度为O(n<sup>2)。</sup><br/>
<strong>适用性</strong>：不适用于带有负权值的图。</p>

<h3 id="toc_30">Floyd</h3>

<p>floyd算法是求图中<strong>任意两个顶点间的最短距离</strong>。</p>

<p>过程：</p>

<ul>
<li>初始化一个矩阵A，\(A^{(-1)}\)[i][j]=G.edges[i][j]。</li>
<li>迭代n轮：\(A^{(k)}\)=Min{\(A^{(k-1)}\)[i][j], \(A^{(k-1)}\)[i][k]+\(A^{(k-1)}\)[k][j]}</li>
</ul>

<p>\(A^{(k)}\)矩阵存储了前K个节点之间的最短路径，基于最短路径的性质，第K轮迭代的时候会求出第K个节点到其他K-1个节点的最短路径。</p>

<p>图解：<br/>
<img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181025134249477-410650124.png" alt=""/></p>

<pre class="line-numbers"><code class="language-text">void Floyd(MGraph G, int Path[][MAXSIZE])
{
    int A[MAXSIZE][MAXSIZE];
    for(int i=0;i&lt;G.vexnum;i++)
        for(int j=0;j&lt;G.vexnum;j++)
        {
            A[i][j]=G.edges[i][j];
            Path[i][j]=-1;
        }

    for(int k=0;k&lt;G.vexnum;k++)
        for(int i=0;i&lt;G.vexnum;i++)
            for(int j=0;j&lt;G.vexnum;j++)
                if(A[i][j]&gt;A[i][k]+A[k][j])
                {
                    A[i][j]=A[i][k]+A[k][j];
                    Path[i][j]=k;
                }
}
</code></pre>

<p><strong>复杂度分析</strong>：主循环为三个for，O(n<sup>3)。</sup><br/>
<strong>适用性分析</strong>：允许图带有负权边，但是不能有负权边构成的回路。</p>

<h2 id="toc_31">拓扑排序</h2>

<h3 id="toc_32">概念</h3>

<ul>
<li><strong>DAG</strong>，有向无环图。</li>
<li><strong>AOV网</strong>，用<Vi,Vj>表示 Vi 先于 Vj 的关系构成的DAG。即每个点表示一种活动，活动有先后顺序。</li>
<li><strong>拓扑排序</strong>，满足以下关系的DAG，即求AOV网中可能的活动顺序：
<ul>
<li>每个顶点只出现一次。</li>
<li>若顶点 A 在顶点 B 之前，则不存在 B 到 A 的路径。</li>
</ul></li>
</ul>

<h3 id="toc_33">算法</h3>

<p>一种比较常用的拓扑排序算法：</p>

<ol>
<li>从DAG图中选出一个没有前驱的顶点删除。</li>
<li>从图中删除所有以该点为起点的边。</li>
<li>重复1,2。直到图为空。若不为空则必有环。</li>
</ol>

<p><img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181025140044978-873290439.png" alt=""/></p>

<p>最终得到的拓扑排序结果为：1,2,4,3,5。</p>

<h2 id="toc_34">关键路径</h2>

<h3 id="toc_35">概念</h3>

<p>在带权有向图中，若权值表示活动开销则为<strong>AOE网</strong>。<br/>
<strong>AOE网的性质</strong>：</p>

<ol>
<li>只有顶点的的事件发生后，后继的顶点的事件才能发生。</li>
<li>只有顶点的所有前驱事件发生完后，才能进行该顶点的事件。</li>
</ol>

<p><strong>源点</strong>：AOE 中仅有一个入度为0的顶点。<br/>
<strong>汇点</strong>：AOE 中仅有一个出度为0的顶点。</p>

<p><strong>关键路径</strong>：从源点到汇点的所有路径中路径长度<strong>最大</strong>的。<br/>
<strong>关键路径长度</strong>：完成整个工程的<strong>最短</strong>时间。<br/>
<strong>关键活动</strong>：关键路径上的活动。</p>

<h3 id="toc_36">算法</h3>

<p>先定义几个量：</p>

<ol>
<li><code>ve(k)</code>，事件 vk 最早发生时间。决定了所有从 vj 开始的活动能开工的最早时间。
<ul>
<li>ve(源点)=0。</li>
<li>ve(k)=Max{ve(j)+Weight(vj,vk)}。</li>
<li>注意从前往后算。</li>
</ul></li>
<li><code>vl(k)</code>，事件 vk 最迟发生的时间。保证所指向的事件 vi 能在 ve(i)之前完成。
<ul>
<li>vl(汇点)=ve(汇点)。</li>
<li>vl(k)=Min{vl(k)-Weight(vj,vk)}。</li>
<li>注意从后往前算。</li>
</ul></li>
<li><code>e(i)</code>，活动 ai 最早开始的时间。
<ul>
<li>若边<vk,vj>表示活动 ai，则有 e(i)=ve(k)。</li>
</ul></li>
<li><code>l(i)</code>，活动 ai 最迟开始时间。
<ul>
<li>l(i)=vl(i)-Weight(vk, vj)。</li>
</ul></li>
<li><code>d(i)</code>，活动完成的时间余量。
<ul>
<li>d(i)=l(i)-e(i)。</li>
<li>l(i)=e(i)则为关键活动。</li>
</ul></li>
</ol>

<p>求关键路径算法如下：</p>

<ol>
<li>求 AOE 网中所有事件的 ve()</li>
<li>求 AOE 网中所有事件的 vl()</li>
<li>求 AOE 网中所有活动的 e()</li>
<li>求 AOE 网中所有活动的 l()</li>
<li>求 AOE 网中所有活动的 d()</li>
<li>所有 d()=0的活动构成关键路径</li>
</ol>

<p><img src="https://img2018.cnblogs.com/blog/1139760/201810/1139760-20181025160426864-97005912.png" alt=""/></p>

<p>可以求得关键路径为(v1,v3,v4,v6)</p>

<h2 id="toc_37">习题</h2>


</div>

<br /><br />
<hr />

<div class="row clearfix">
  <div class="large-6 columns">
	<div class="text-left" style="padding:15px 0px;">
		
	        <a href="15376956161325.html"  title="Previous Post: 数据结构-树">&laquo; 数据结构-树</a>
	    
	</div>
  </div>
  <div class="large-6 columns">
	<div class="text-right" style="padding:15px 0px;">
		
	        <a href="15366378611089.html" 
	        title="Next Post: 数据结构-排序">数据结构-排序 &raquo;</a>
	    
	</div>
  </div>
</div>

<div class="row">
<div style="padding:0px 0.93em;" class="share-comments">

</div>
</div>
<script type="text/javascript">
	$(function(){
		var currentURL = '15366535602244.html';
		$('#side-nav a').each(function(){
			if($(this).attr('href') == currentURL){
				$(this).parent().addClass('active');
			}
		});
	});
</script>  
</div></div>


<div class="page-bottom">
  <div class="row">
  <hr />
  <div class="small-9 columns">
  <p class="copyright">Copyright &copy; 2015
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a>,&nbsp; 
Theme used <a target="_blank" href="http://github.com">GitHub CSS</a>.</p>
  </div>
  <div class="small-3 columns">
  <p class="copyright text-right"><a href="#header">TOP</a></p>
  </div>
   
  </div>
</div>

        </section>
      </div>
    </div>
    
    
    <script src="asset/js/foundation.min.js"></script>
    <script src="asset/js/foundation/foundation.offcanvas.js"></script>
    <script>
      $(document).foundation();

     
    </script>
    
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

  </body>
</html>
